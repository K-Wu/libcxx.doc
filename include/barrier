// -*- C++ -*-
//===--------------------------- barrier ----------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#ifndef _LIBCPP_BARRIER
#define _LIBCPP_BARRIER

/*
    barrier synopsis

namespace std 
{

  template<class CompletionFunction = see below>
  class barrier 
  {
  public:
    using arrival_token = see below;

    constexpr explicit barrier(ptrdiff_t phase_count,
                               CompletionFunction f = CompletionFunction());
    ~barrier();

    barrier(const barrier&) = delete;
    barrier& operator=(const barrier&) = delete;

    [[nodiscard]] arrival_token arrive(ptrdiff_t update = 1);
    void wait(arrival_token&& arrival) const;

    void arrive_and_wait();
    void arrive_and_drop();

  private:
    CompletionFunction completion; // exposition only
  };

}

*/

#ifndef __simt__
#include <__config>
#include <__threading_support>
#include <atomic>
#include <cassert>
# ifndef _LIBCPP_HAS_NO_TREE_BARRIER
#  include <thread>
#  include <vector>
# endif
#endif

#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
#pragma GCC system_header
#endif

#ifdef _LIBCPP_HAS_NO_THREADS
# error <barrier> is not supported on this single threaded system
#endif

_LIBCPP_BEGIN_NAMESPACE_STD

struct EmptyCompletionF 
{
    inline _LIBCPP_INLINE_VISIBILITY
    void operator()() noexcept { }
};

#ifndef _LIBCPP_HAS_NO_TREE_BARRIER

template<class CompletionF = EmptyCompletionF, int _Sco = 0>
class alignas(64) __barrier_base {

    ptrdiff_t                       expected;
    __atomic_base<ptrdiff_t, _Sco>  expected_adjustment;
    CompletionF                     completion;

    using __phase_t = uint8_t;
    __atomic_base<__phase_t, _Sco>  phase;

    struct alignas(64) __state_t 
    {
        struct {
            __atomic_base<__phase_t, _Sco> phase = ATOMIC_VAR_INIT(0);
        } tickets[64];
    };
    ::std::vector<__state_t>   state;

    inline _LIBCPP_INLINE_VISIBILITY
    bool __arrive(__phase_t const old_phase)
    {
        __phase_t const half = old_phase + 1, full = old_phase + 2;
#ifndef _LIBCPP_HAS_NO_THREAD_FAVORITE_HASH
        ptrdiff_t current = __libcpp_thread_favorite_hash, 
#else
        ptrdiff_t current = 0, 
#endif
                  current_expected = expected, 
                  last_node = (current_expected >> 1);
        for(size_t round = 0;; ++round) {
            assert(round <= 63);
            if(current_expected == 1)
                return true;
            for(;;++current) {
#ifndef _LIBCPP_HAS_NO_THREAD_FAVORITE_HASH
                if(0 == round) {
                    if(current >= current_expected)
                        current = 0;
                    __libcpp_thread_favorite_hash = current;
                }
#endif
                assert(current <= last_node);
                __phase_t expect = old_phase;
                if(current == last_node && (current_expected & 1))
                {
                    if(state[current].tickets[round].phase.compare_exchange_strong(expect, full, memory_order_acq_rel))
                        break;    // I'm 1 in 1, go to next round
                    assert(expect == full);
                }
                else if(state[current].tickets[round].phase.compare_exchange_strong(expect, half, memory_order_acq_rel)) 
                {
                    return false; // I'm 1 in 2, done with arrival
                }
                else if(expect == half)
                {
                    if(state[current].tickets[round].phase.compare_exchange_strong(expect, full, memory_order_acq_rel))
                        break;    // I'm 2 in 2, go to next round
                    assert(expect == full);
                }
                assert(round == 0 && expect == full);
            }
            current_expected = (current_expected >> 1) + (current_expected & 1);
            current &= ~( 1 << round );
            last_node &= ~( 1 << round );
        }
    }

public:
    using arrival_token = __phase_t;
    
    inline _LIBCPP_INLINE_VISIBILITY
    __barrier_base(ptrdiff_t expected, CompletionF completion = CompletionF()) 
            : expected(expected), expected_adjustment(0), completion(completion), 
              phase(0), state((expected+1) >> 1)
    { 
        assert(expected >= 0);
    }

    inline _LIBCPP_INLINE_VISIBILITY
    ~__barrier_base() = default;

    __barrier_base(__barrier_base const&) = delete;
    __barrier_base& operator=(__barrier_base const&) = delete;

    [[nodiscard]] inline _LIBCPP_INLINE_VISIBILITY
    arrival_token arrive(ptrdiff_t update = 1) 
    {
        assert(update > 0);
        auto old_phase = phase.load(memory_order_relaxed);
        for(; update; --update)
            if(__arrive(old_phase)) {
                completion();
                expected += expected_adjustment.load(memory_order_relaxed);
                expected_adjustment.store(0, memory_order_relaxed);
                phase.store(old_phase + 2, memory_order_release);
            }
        return old_phase;
    }
    inline _LIBCPP_INLINE_VISIBILITY
    void wait(arrival_token&& old_phase) const 
    {
        __libcpp_thread_poll_with_backoff([&]() -> bool {
            return phase.load(memory_order_acquire) != old_phase;
        });
    }
	inline _LIBCPP_INLINE_VISIBILITY
    void arrive_and_wait() 
    {
        wait(arrive());
	}
    inline _LIBCPP_INLINE_VISIBILITY
    void arrive_and_drop() 
    {
        expected_adjustment.fetch_sub(1, memory_order_relaxed);
        (void)arrive();
    }
};

#else

template<class CompletionF, int _Sco = 0>
class __barrier_base {

    alignas(64) __atomic_base<ptrdiff_t, _Sco> expected, arrived;
    alignas(64) CompletionF                    completion;
    alignas(64) __atomic_base<bool, _Sco>      phase;
public:
    using arrival_token = bool;

    _LIBCPP_INLINE_VISIBILITY
    __barrier_base(ptrdiff_t expected, CompletionF completion = CompletionF()) 
        : phase(false), expected(expected), arrived(expected), completion(completion) 
    {
    }

    ~__barrier_base() = default;

    __barrier_base(__barrier_base const&) = delete;
    __barrier_base& operator=(__barrier_base const&) = delete;

    [[nodiscard]] _LIBCPP_INLINE_VISIBILITY
    arrival_token arrive(ptrdiff_t update = 1) 
    {
        auto const old_phase = phase.load(memory_order_relaxed);
        auto const result = arrived.fetch_sub(update, memory_order_acq_rel) - update;
        assert(result >= 0);
        auto const new_expected = expected.load(memory_order_relaxed);
        if(0 == result) {
            completion();
            arrived.store(new_expected, memory_order_relaxed);
            phase.store(!old_phase, memory_order_release);
            atomic_notify_all(&phase);
        }
        return old_phase;
    }
    _LIBCPP_INLINE_VISIBILITY
    void wait(arrival_token&& old_phase) const 
    {
        phase.wait(old_phase, memory_order_acquire);
    }
	_LIBCPP_INLINE_VISIBILITY 
    void arrive_and_wait() 
    {
        wait(arrive());
	}
    _LIBCPP_INLINE_VISIBILITY
    void arrive_and_drop() 
    {
        expected.fetch_sub(1, memory_order_relaxed);
        (void)arrive();
    }
};

template<int _Sco>
class __barrier_base<EmptyCompletionF, _Sco> {

    static constexpr uint64_t expected_unit = 1ull;
    static constexpr uint64_t arrived_unit = 1ull << 32;
    static constexpr uint64_t expected_mask = arrived_unit - 1;
    static constexpr uint64_t phase_bit = 1ull << 63;
    static constexpr uint64_t arrived_mask = (phase_bit - 1) & ~expected_mask;

    alignas(64) __atomic_base<uint64_t, _Sco> phase_arrived_expected;

    static inline _LIBCPP_INLINE_VISIBILITY
    constexpr uint64_t __init(ptrdiff_t count) _NOEXCEPT 
    {
        return (((1u << 31) - count) << 32) 
              | ((1u << 31) - count);
    }

public:
    using arrival_token = uint64_t;

    _LIBCPP_INLINE_VISIBILITY
    __barrier_base(ptrdiff_t count, EmptyCompletionF = EmptyCompletionF()) 
        : phase_arrived_expected(__init(count)) { 
    }

    ~__barrier_base() = default;

    __barrier_base(__barrier_base const&) = delete;
    __barrier_base& operator=(__barrier_base const&) = delete;

    [[nodiscard]] inline _LIBCPP_INLINE_VISIBILITY
    arrival_token arrive(ptrdiff_t update = 1) 
    {
        auto const inc = arrived_unit * update;
        auto const old = phase_arrived_expected.fetch_add(inc, memory_order_acq_rel);
        if((old ^ (old + inc)) & phase_bit) {
            phase_arrived_expected.fetch_add((old & expected_mask) << 32, memory_order_relaxed);
            phase_arrived_expected.notify_all();
        }
        return old & phase_bit;
    }
    inline _LIBCPP_INLINE_VISIBILITY 
    void wait(arrival_token&& phase) const
    {
#if defined(__CUDACC__)
        __libcpp_thread_poll_with_backoff([&] _LIBCPP_INLINE_VISIBILITY () -> bool
#else
        __libcpp_thread_poll_with_backoff([&]() -> bool
#endif
        {
            uint64_t const current = phase_arrived_expected.load(memory_order_acquire);
            return ((current & phase_bit) != phase);
        });
    }
	inline _LIBCPP_INLINE_VISIBILITY
    void arrive_and_wait() 
    {
        wait(arrive());
	}
    inline _LIBCPP_INLINE_VISIBILITY
    void arrive_and_drop() 
    {
        phase_arrived_expected.fetch_add(expected_unit, memory_order_relaxed);
        (void)arrive();
    }
};

#endif //_LIBCPP_HAS_NO_TREE_BARRIER

template<class CompletionF = EmptyCompletionF>
class barrier : public __barrier_base<CompletionF> {
public:
    _LIBCPP_INLINE_VISIBILITY
    barrier(ptrdiff_t count, CompletionF completion = CompletionF()) 
        : __barrier_base<CompletionF>(count, completion) { 
    }
};

_LIBCPP_END_NAMESPACE_STD

#endif //_LIBCPP_BARRIER
