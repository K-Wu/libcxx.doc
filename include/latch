// -*- C++ -*-
//===--------------------------- latch -----------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#ifndef _LIBCPP_LATCH
#define _LIBCPP_LATCH

/*
    latch synopsis

namespace std 
{

  class latch 
  {
  public:
    constexpr explicit latch(ptrdiff_t expected);
    ~latch();

    latch(const latch&) = delete;
    latch& operator=(const latch&) = delete;
    
    void count_down(ptrdiff_t update = 1);
    bool try_wait() const noexcept;
    void wait() const;
    void arrive_and_wait(ptrdiff_t update = 1);

  private:
    ptrdiff_t counter; // exposition only
  };
  
} 

*/

#ifndef __simt__
#include <__config>
#include <__threading_support>
#include <atomic>
#endif

#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
#pragma GCC system_header
#endif

#ifdef _LIBCPP_HAS_NO_THREADS
# error <latch> is not supported on this single threaded system
#endif

_LIBCPP_BEGIN_NAMESPACE_STD

template<int _Sco = 0>
class __latch_base
{
    alignas(64) __atomic_base<ptrdiff_t, _Sco> counter;
public:
    inline _LIBCPP_INLINE_VISIBILITY
    constexpr explicit __latch_base(ptrdiff_t expected) 
        : counter(expected) { }

    ~__latch_base() = default;
    __latch_base(const __latch_base&) = delete;
    __latch_base& operator=(const __latch_base&) = delete;

    inline _LIBCPP_INLINE_VISIBILITY
    void count_down(ptrdiff_t update = 1) 
    {
        assert(update > 0);
        auto const old = counter.fetch_sub(update, std::memory_order_release);
        assert(old >= update);
#ifndef __NO_WAIT
        if(old == update)
            counter.notify_all();
#endif
    }
    inline _LIBCPP_INLINE_VISIBILITY
    bool try_wait() const noexcept 
    {
        return counter.load(std::memory_order_acquire) == 0;
    }
    inline _LIBCPP_INLINE_VISIBILITY
    void wait() const 
    {
        while(1) {
            auto const current = counter.load(std::memory_order_acquire);
            if(current == 0) 
                return;
#ifndef __NO_WAIT
            counter.wait(current, std::memory_order_relaxed)
#endif
            ;
        }
    }
    inline _LIBCPP_INLINE_VISIBILITY
    void arrive_and_wait(ptrdiff_t update = 1) 
    {
        count_down(update);
        wait();
    }
};

using latch = __latch_base<>;

_LIBCPP_END_NAMESPACE_STD

#endif //_LIBCPP_LATCH
