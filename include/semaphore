// -*- C++ -*-
//===--------------------------- semaphore --------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#ifndef _LIBCPP_SEMAPHORE
#define _LIBCPP_SEMAPHORE

/*
    semaphore synopsis

namespace std {

template<ptrdiff_t least_max_value = implementation-defined>
class counting_semaphore 
{
public:
static constexpr ptrdiff_t max() noexcept;

constexpr explicit counting_semaphore(ptrdiff_t desired);
~counting_semaphore();

counting_semaphore(const counting_semaphore&) = delete;
counting_semaphore& operator=(const counting_semaphore&) = delete;

void release(ptrdiff_t update = 1);
void acquire();
bool try_acquire() noexcept;
template<class Rep, class Period>
    bool try_acquire_for(const chrono::duration<Rep, Period>& rel_time);
template<class Clock, class Duration>
    bool try_acquire_until(const chrono::time_point<Clock, Duration>& abs_time);

private:
ptrdiff_t counter; // exposition only
};

using binary_semaphore = counting_semaphore<1>;

}

*/

#ifndef __simt__
#include <__config>
#include <__threading_support>
#include <atomic>
#endif

#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
#pragma GCC system_header
#endif

#ifdef _LIBCPP_HAS_NO_THREADS
# error <semaphore> is not supported on this single threaded system
#endif

_LIBCPP_BEGIN_NAMESPACE_STD

template<int _Sco, ptrdiff_t least_max_value>
class __atomic_semaphore_base 
{
    _LIBCPP_INLINE_VISIBILITY
    bool __fetch_sub_if_slow(ptrdiff_t old) 
    {
        while (old != 0) {
            if (count.compare_exchange_weak(old, old - 1, memory_order_acquire, memory_order_relaxed))
                return true; 
        }
        return false;
    }

    _LIBCPP_INLINE_VISIBILITY
    bool __fetch_sub_if() 
    {
        ptrdiff_t old = count.load(memory_order_acquire);
        if (old == 0)
            return false;
        if(count.compare_exchange_weak(old, old - 1, memory_order_acquire, memory_order_relaxed))
            return true;
        return __fetch_sub_if_slow(old); // fail only if not available
    }

    _LIBCPP_INLINE_VISIBILITY
    void __wait_slow() 
    {
        while (1) {
            ptrdiff_t const old = count.load(memory_order_acquire);
            if(old != 0)
                break;
            count.wait(old, memory_order_relaxed);
        }
    }

    _LIBCPP_INLINE_VISIBILITY
    bool __acquire_slow_timed(chrono::nanoseconds const& rel_time) 
    {
        return __libcpp_thread_poll_with_backoff([=]() {
            ptrdiff_t const old = count.load(memory_order_acquire);
            return old != 0 && __fetch_sub_if_slow(old);
        }, rel_time);
    }
    __atomic_base<ptrdiff_t, _Sco> count;

public:
    static constexpr ptrdiff_t max() noexcept 
    { 
        return numeric_limits<ptrdiff_t>::max(); 
    }

    _LIBCPP_INLINE_VISIBILITY
    __atomic_semaphore_base(ptrdiff_t count) : count(count) { }

    ~__atomic_semaphore_base() = default;

    __atomic_semaphore_base(__atomic_semaphore_base const&) = delete;
    __atomic_semaphore_base& operator=(__atomic_semaphore_base const&) = delete;

    _LIBCPP_INLINE_VISIBILITY
    void release(ptrdiff_t update = 1) 
    {
        count.fetch_add(update, memory_order_release);
        if(update > 1)
            count.notify_all();
        else
            count.notify_one();
    }

    _LIBCPP_INLINE_VISIBILITY
    void acquire() 
    {
        while (!try_acquire())
            __wait_slow();
    }

    _LIBCPP_INLINE_VISIBILITY
    bool try_acquire() noexcept 
    {
        return __fetch_sub_if();
    }

    template <class Clock, class Duration>
    _LIBCPP_INLINE_VISIBILITY
    bool try_acquire_until(chrono::time_point<Clock, Duration> const& abs_time) 
    {
        if (try_acquire())
            return true;
        else
            return __acquire_slow_timed(abs_time - Clock::now());
    }

    template <class Rep, class Period>
    _LIBCPP_INLINE_VISIBILITY
    bool try_acquire_for(chrono::duration<Rep, Period> const& rel_time) 
    {

        if (try_acquire())
            return true;
        else
            return __acquire_slow_timed(rel_time);
    }
};

#ifndef _LIBCPP_USE_NATIVE_SEMAPHORES

template<int _Sco>
class __atomic_semaphore_base<_Sco, 1> {

    _LIBCPP_INLINE_VISIBILITY
    bool __acquire_slow_timed(chrono::nanoseconds const& rel_time) 
    {
        return __libcpp_thread_poll_with_backoff([=]() {
            return try_acquire();
        }, rel_time);
    }
    __atomic_base<int, _Sco> available;

public:
    static constexpr ptrdiff_t max() noexcept { return 1; }

    _LIBCPP_INLINE_VISIBILITY
    __atomic_semaphore_base(ptrdiff_t available) : available(available) { }

    ~__atomic_semaphore_base() = default;

    __atomic_semaphore_base(__atomic_semaphore_base const&) = delete;
    __atomic_semaphore_base& operator=(__atomic_semaphore_base const&) = delete;

    _LIBCPP_INLINE_VISIBILITY
    void release(ptrdiff_t update = 1) 
    {
        available.store(1, memory_order_release);
        available.notify_one();
    }

    _LIBCPP_INLINE_VISIBILITY
    void acquire() 
    {
        while (!__builtin_expect(try_acquire(), 1))
            available.wait(0, memory_order_relaxed);
    }

    _LIBCPP_INLINE_VISIBILITY
    bool try_acquire() noexcept 
    {
        return 1 == available.exchange(0, memory_order_acquire);
    }

    template <class Clock, class Duration>
    _LIBCPP_INLINE_VISIBILITY
    bool try_acquire_until(chrono::time_point<Clock, Duration> const& abs_time) 
    {
        if (__builtin_expect(try_acquire(), 1))
            return true;
        else
            return __acquire_slow_timed(abs_time - Clock::now());
    }

    template <class Rep, class Period>
    _LIBCPP_INLINE_VISIBILITY
    bool try_acquire_for(chrono::duration<Rep, Period> const& rel_time) 
    {
        if (__builtin_expect(try_acquire(), 1))
            return true;
        else
            return __acquire_slow_timed(rel_time);
    }
};

#else

template<int _Sco>
class __sem_semaphore_base {

    _LIBCPP_INLINE_VISIBILITY
    bool __backfill(bool success) 
    {
#ifndef _LIBCPP_HAS_NO_SEMAPHORE_BACK_BUFFER
        if(success) {
            auto const back_amount = __backbuffer.fetch_sub(2, memory_order_acquire);
            bool const post_one = back_amount > 0;
            bool const post_two = back_amount > 1;
            auto const success = (!post_one || __libcpp_semaphore_post(&__semaphore)) && 
                                 (!post_two || __libcpp_semaphore_post(&__semaphore));
            assert(success);
            if(!post_one || !post_two)
                __backbuffer.fetch_add(!post_one ? 2 : 1, memory_order_relaxed);
        }
#endif
        return success;
    }

    _LIBCPP_INLINE_VISIBILITY
    bool __try_acquire_fast() 
    {
#ifndef _LIBCPP_HAS_NO_SEMAPHORE_FRONT_BUFFER

        ptrdiff_t old;
        __libcpp_thread_poll_with_backoff([&]() {
            old = __frontbuffer.load(memory_order_relaxed);
            return 0 != (old >> 32);
        }, chrono::microseconds(5));

//        // boldly assume the semaphore is free with a count of 1, just because
//        ptrdiff_t old = 1ll << 32;

        // always steal if you can
        while(old >> 32)
            if(__frontbuffer.compare_exchange_weak(old, old - (1ll << 32), memory_order_acquire))
                return true;
        // record we're waiting
        old = __frontbuffer.fetch_add(1ll, memory_order_release);
        // ALWAYS steal if you can!
        while(old >> 32)
            if(__frontbuffer.compare_exchange_weak(old, old - (1ll << 32), memory_order_acquire))
                break;
        // not going to wait after all
        if(old >> 32)
            return __try_done(true);
#endif
        // the wait has begun...
        return false;
    }

    _LIBCPP_INLINE_VISIBILITY
    bool __try_done(bool success) 
    {
#ifndef _LIBCPP_HAS_NO_SEMAPHORE_FRONT_BUFFER
        // record we're NOT waiting
        __frontbuffer.fetch_sub(1ll, memory_order_release);
#endif
        return __backfill(success);
    }

    _LIBCPP_INLINE_VISIBILITY
    void __release_slow(ptrdiff_t post_amount) 
    {
    #ifndef _LIBCPP_HAS_NO_SEMAPHORE_BACK_BUFFER
        bool const post_one = post_amount > 0;
        bool const post_two = post_amount > 1;
        if(post_amount > 2)
            __backbuffer.fetch_add(post_amount - 2, memory_order_acq_rel);
        auto const success = (!post_one || __libcpp_semaphore_post(&__semaphore)) && 
                             (!post_two || __libcpp_semaphore_post(&__semaphore));
        assert(success);
    #else
        for(; post_amount; --post_amount) {
            auto const success = __libcpp_semaphore_post(&__semaphore);
            assert(success);
        }
    #endif
    }

    __libcpp_semaphore_t __semaphore;
#ifndef _LIBCPP_HAS_NO_SEMAPHORE_FRONT_BUFFER
    __atomic_base<ptrdiff_t, _Sco> __frontbuffer;
#endif
#ifndef _LIBCPP_HAS_NO_SEMAPHORE_BACK_BUFFER
    __atomic_base<ptrdiff_t, _Sco> __backbuffer;
#endif

public:
    static constexpr ptrdiff_t max() noexcept {
        return _LIBCPP_SEMAPHORE_MAX;
    }
    
    _LIBCPP_INLINE_VISIBILITY
    __sem_semaphore_base(ptrdiff_t count = 0) : __semaphore()
#ifndef _LIBCPP_HAS_NO_SEMAPHORE_FRONT_BUFFER
    , __frontbuffer(count << 32)
#endif
#ifndef _LIBCPP_HAS_NO_SEMAPHORE_BACK_BUFFER
    , __backbuffer(0)
#endif
    { 
        assert(count <= max());
        auto const success = 
#ifndef _LIBCPP_HAS_NO_SEMAPHORE_FRONT_BUFFER
            __libcpp_semaphore_init(&__semaphore, 0);
#else
            __libcpp_semaphore_init(&__semaphore, count);
#endif
        assert(success);
    }

    _LIBCPP_INLINE_VISIBILITY
    ~__sem_semaphore_base() {
#ifndef _LIBCPP_HAS_NO_SEMAPHORE_FRONT_BUFFER
        assert(0 == (__frontbuffer.load(memory_order_relaxed) & ~0u));
#endif
        auto const success = __libcpp_semaphore_destroy(&__semaphore);
        assert(success);
    }

    __sem_semaphore_base(const __sem_semaphore_base&) = delete;
    __sem_semaphore_base& operator=(const __sem_semaphore_base&) = delete;

    _LIBCPP_INLINE_VISIBILITY
    void release(ptrdiff_t update = 1) 
    {
#ifndef _LIBCPP_HAS_NO_SEMAPHORE_FRONT_BUFFER
        // boldly assume the semaphore is taken but uncontended
        ptrdiff_t old = 0;
        // try to fast-release as long as it's uncontended
        while(0 == (old & ~0ul))
            if(__frontbuffer.compare_exchange_weak(old, old + (update << 32), memory_order_acq_rel))
                return;
#endif
        // slow-release it is
        __release_slow(update);
    }

    _LIBCPP_INLINE_VISIBILITY
    void acquire() 
    {
        if(!__try_acquire_fast())
            __try_done(__libcpp_semaphore_wait(&__semaphore));
    }

    _LIBCPP_INLINE_VISIBILITY
    bool try_acquire() noexcept 
    {
        return try_acquire_for(chrono::nanoseconds(0));
    }

    template <class Clock, class Duration>
    _LIBCPP_INLINE_VISIBILITY
    bool try_acquire_until(chrono::time_point<Clock, Duration> const& abs_time) 
    {
        auto const current = max(Clock::now(), abs_time);
        return try_acquire_for(chrono::duration_cast<chrono::nanoseconds>(abs_time - current));
    }

    template <class Rep, class Period>
    _LIBCPP_INLINE_VISIBILITY
    bool try_acquire_for(chrono::duration<Rep, Period> const& rel_time) 
    {
        return __try_acquire_fast() ||
               __try_done(__libcpp_semaphore_wait_timed(&__semaphore, rel_time));
    }
};

#endif //_LIBCPP_HAS_NO_SEMAPHORES

template<ptrdiff_t least_max_value, int _Sco>
using __semaphore_base = 
#ifdef _LIBCPP_USE_NATIVE_SEMAPHORES
    typename conditional<least_max_value <= __sem_semaphore_base<_Sco>::max(), 
                        __sem_semaphore_base<_Sco>, 
                        __atomic_semaphore_base<_Sco, least_max_value>>::type
#else
    __atomic_semaphore_base<_Sco, least_max_value>
#endif
    ;

template<ptrdiff_t least_max_value = INT_MAX>
class counting_semaphore : public __semaphore_base<least_max_value, 0> 
{
    static_assert(least_max_value <= __semaphore_base<least_max_value, 0>::max(), "");
public:
    _LIBCPP_INLINE_VISIBILITY
    counting_semaphore(ptrdiff_t count = 0) : __semaphore_base<least_max_value, 0>(count) { }
    ~counting_semaphore() = default;

    counting_semaphore(const counting_semaphore&) = delete;
    counting_semaphore& operator=(const counting_semaphore&) = delete;
};

using binary_semaphore = counting_semaphore<1>;

_LIBCPP_END_NAMESPACE_STD

#endif //_LIBCPP_SEMAPHORE
